<html><head><title>@elentok - </title><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"/><style type="text/css">body {
  font-family: sans-serif;
  background: #242424;
  color: #e9e9e9;
  font-size: 18px;
  line-height: 1.5;
}

a, a:visited {
  color: #98adec;
}

.e-page {
  margin: auto;
  max-width: 700px;
  padding: 15px;
}</style></head><body><div class="e-page"><a class="e-header" href="/"><div class="e-header__avatar"><div class="e-avatar"></div></div><h2>Elentok's Blog</h2></a><div class="e-post"><h1 class="e-post__title">Autocomplete textbox for multiple keywords/tags entry in PySide</h1><div class="e-post__date">August 12th, 2011</div><div class="e-post__body"><p>Last month I started writing <a href="http://elentok.blogspot.com/2011/06/qtodotxt-cross-platform-todotxt-gui.html">QTodoTxt</a>, a PySide (Python Qt bindings) GUI for the <a href="http://todotxt.com/">todo.txt</a> concept.</p>
<p>While using it for my own todo list I noticed several features that were missing (I intend to implement them all in due time), one of these features was auto-completion for projects and contexts when editing or creating a new task, something like this:</p>
<div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-42K_XxQ5_tc/TkT6dJxiN7I/AAAAAAAABLs/NvFKWGbf7Ow/s1600/task_editor.png"><img src="http://3.bp.blogspot.com/-42K_XxQ5_tc/TkT6dJxiN7I/AAAAAAAABLs/NvFKWGbf7Ow/s400/task_editor.png" alt=""></a></div>

<p>After some googling I found the built-in QCompleter component that can be easily attached to any QLineEdit control and allow easy auto-completion:</p>
<pre>  lineEdit = QtGui.QLineEdit()
  completer = QtGui.QCompleter(
      ['one', 'two', 'three', 'four'])
  lineEdit.setCompleter(lineEdit)
</pre>

<p>However, this only allows auto-completing for the first word and I wanted to auto-completion for every word in the text. So I went back to google and found <a href="http://developer.qt.nokia.com/forums/viewthread/5376">a post</a> in the Qt developers forum that shows a simple implementation of this in C++.</p>
<p>Instead of using the QLineEdit&#39;s &quot;setCompleter&quot; method (which wasn&#39;t available for QTextEdit he was using), his implementation handles opening the completer manually and just attaches the completer to the QLineEdit using the QCompleter.setWidget method.</p>
<p>To create my own auto-complete control I implemented his C++ control in python and added some extra features of my own. At first I created the AutoCompleteEdit class that inherits from QLineEdit and initializes the QCompleter:</p>
<pre>from PySide import QtCore, QtGui

class AutoCompleteEdit(QtGui.QLineEdit):
  def __init__(self, model, separator = ' ', \
      addSpaceAfterCompleting = True):
    super(AutoCompleteEdit, self).__init__()
    self._separator = separator
    self._addSpaceAfterCompleting = \
        addSpaceAfterCompleting
    self._completer = QtGui.QCompleter(model)
    self._completer.setWidget(self)
    self.connect(
        self._completer,
        QtCore.SIGNAL('activated(QString)'),
        self._insertCompletion)
    self._keysToIgnore = [QtCore.Qt.Key_Enter,
                          QtCore.Qt.Key_Return,
                          QtCore.Qt.Key_Escape,
                          QtCore.Qt.Key_Tab]</pre>

<p>I overrid the keyPressEvent method of QLineEdit to handle the completion manually:</p>
<pre>  def keyPressEvent(self, event):
    if self._completer.popup().isVisible():
      if event.key() in self._keysToIgnore:
        event.ignore()
        return
    super(AutoCompleteEdit, self).keyPressEvent(event)
    completionPrefix = self.textUnderCursor()
    if completionPrefix != self._completer.completionPrefix():
      self._updateCompleterPopupItems(completionPrefix)
    if len(event.text()) > 0 and len(completionPrefix) > 0:
      self._completer.complete()
    if len(completionPrefix) == 0:
      self._completer.popup().hide()
</pre>

<p>This method performs the following tasks:</p>
<ul>
<li>If the user pressed Enter, Escape or Tab the method ignores them and returns.</li>
<li>Every other character is forwarded to the base method.</li>
<li>Filters the items displayed in the completer popup to only show the items that start with the text the user started to write (the completion prefix).</li>
</ul>
<p>Thank you for reading,
You can see the full code in my Bitbucket repository: <a href="https://bitbucket.org/3david/qtodotxt/src/ec1e74eef575/qtodotxt/ui/controls/autocomplete_lineedit.py">https://bitbucket.org/3david/qtodotxt/src/ec1e74eef575/qtodotxt/ui/controls/autocomplete_lineedit.py</a></p>
<p>Please feel free to leave comments,</p>
<p>David.</p>
</div><div class="e-post__next"><span>Next:</span><a href="/2011/08/tip-removing-changset-from-mercurial.html">Tip: Removing a changset from a Mercurial repository</a></div></div></div><style type="text/css">@import "/style.css";
@import url('https://fonts.googleapis.com/css?family=Open+Sans:400,700|Source+Code+Pro');
</style><script type="text/javascript">(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-31707322-2', 'auto');
ga('send', 'pageview');</script></body></html>