<html><head><title>@elentok - </title><style type="text/css">body {
  font-family: sans-serif;
  background: #242424;
  color: #e9e9e9;
  font-size: 18px;
  line-height: 1.5;
}

pre, code {
  font-family: 'Source Code Pro';
}

pre {
  padding: 15px;
  background-color: #121212;
  border-radius: 5px;
  line-height: 1.3;
}

a, a:visited {
  color: #98adec;
}

.e-page {
  margin: auto;
  max-width: 700px;
}</style></head><body><div class="e-page"><a class="e-header" href="/"><div class="e-header__avatar"><div class="e-avatar"></div></div><h1>Elentok's Blog</h1></a><h2>Data-binding the SelectedItem property of the WPF TreeView</h2><div><p>In a new WPF application I&#39;m writing I needed to bind the &quot;SelectedItem&quot; property of the TreeView control to the &quot;SelectedItem&quot; property of its <a href="http://blogs.msdn.com/dphill/archive/2009/01/31/the-viewmodel-pattern.aspx">ViewModel</a>; but, alas, the TreeView&#39;s &quot;SelectedItem&quot; property is read-only...</p>
<div>After some googling I found the <a href="http://www.codeproject.com/KB/WPF/versatile_treeview.aspx">Versatile TreeView</a> by Philip Sumi which adds the property I wanted, but since I&#39;m learning WPF and want a deeper understanding I decided to write my own (and use Philip&#39;s TreeView as reference).</div>

<div>In the code I noticed a lot of dependency properties, and I figured its time to learn what are dependency properties and how do they work; again, some googling brought me to <a href="http://www.switchonthecode.com/tutorials/wpf-tutorial-introduction-to-dependency-properties">this post</a> which I think gives a very good explanation of dependency properties.

<div>Now that I knew what I had to do, I started writing the &quot;EnhancedTreeView&quot; class (which is based on the TreeView class).</div>

<div>At first I thought about overriding the &quot;SelectedItem&quot; property but it didn&#39;t go very smooth so I added the &quot;SelectedObject&quot; property.</div>

<div>I added a callback to the dependency-property-changed event (see &quot;SelectedObjectChangedCallback&quot;) and when the property was changed I needed to change the selected item; but, alas again!, the selected item is read-only...</div>

<div>Some more googling brought me to this <a href="http://quickduck.com/blog/2008/12/11/selecting-an-item-in-a-treeview-in-wpf/">blog post</a> which uses the &quot;ItemsContainerGenerator&quot; to find the matching TreeViewItem for the object I want to select.</div>

<div>And here&#39;s the final code:</div>

<div>

<pre>
/// <summary>
/// This treeview class allows databinding the
/// &quot;SelectedObject&quot; property
/// </summary>
public class EnhancedTreeView : TreeView
{
 #region SelectedObject

 /// <summary>
 /// The dependency property that allows use to bind the
 /// &quot;SelectedObject&quot; property
 /// </summary>
 public static readonly DependencyProperty
   SelectedObjectProperty =
     DependencyProperty.Register(
       &quot;SelectedObject&quot;,
       typeof(object),
       typeof(EnhancedTreeView),
       new PropertyMetadata(SelectedObjectChangedCallback));

 /// <summary>
 /// Gets or sets the select object (a writable version of
 /// the &quot;SelectedItem&quot; property)
 /// </summary>
 [Bindable(true)]
 public object SelectedObject
 {
   get { return GetValue(SelectedObjectProperty); }
   set { SetValue(SelectedObjectProperty, value); }
 }

 /// <summary>
 /// This method is called whenever ever the selected
 /// object is changed, and if it was changed from the
 /// outside, this method will set the selected item.
 /// </summary>
 /// <param name="obj"></param>
 /// <param name="eventArgs"></param>
 private static void SelectedObjectChangedCallback
   (DependencyObject obj,
    DependencyPropertyChangedEventArgs eventArgs)
 {
   EnhancedTreeView treeView = (EnhancedTreeView)obj;
   if (!ReferenceEquals(treeView.SelectedItem,
         eventArgs.NewValue))
     SelectItem(treeView, eventArgs.NewValue);
 }

 #endregion

 /// <summary>
 /// Searches the given item in the parent (recursively)
 /// and selects it, returns true if the item was found
 /// and selected, false otherwise.
 /// </summary>
 /// <param name="parent"></param>
 /// <param name="itemToSelect"></param>
 /// <returns></returns>
 private static bool SelectItem
   (ItemsControl parent, object itemToSelect)
 {
   var childTreeNode =
     parent.ItemContainerGenerator
       .ContainerFromItem(itemToSelect)
     as TreeViewItem;

   // if the item to select is directly under &quot;parent&quot;,
   // just select it
   if (childTreeNode != null)
   {
     childTreeNode.Focus();
     return childTreeNode.IsSelected = true;
   }

   // if the item to select is not directly under &quot;parent&quot;,
   // search the child nodes of &quot;parent&quot;
   if (parent.Items.Count &gt; 0)
   {
     foreach (object childItem in parent.Items)
     {
       var childItemsControl = 
         parent.ItemContainerGenerator
           .ContainerFromItem(childItem)
         as ItemsControl;

       if (SelectItem(childItemsControl, itemToSelect))
         return true;
     }
   }

   // if the given item wasn&#39;t found here:
   return false;
 }

 /// <summary>
 /// When the selected item is updated from inside the tree,
 /// this method will update the &quot;SelectedObject&quot; property.
 /// </summary>
 /// <param name="e"></param>
 protected override void OnSelectedItemChanged
   (RoutedPropertyChangedEventArgs<object> e)
 {
   this.SelectedObject = e.NewValue;

   base.OnSelectedItemChanged(e);
 }
}</pre>

</div>

<p></div></p>
<p>To use the EnhancedTreeView all you need is to bind the &quot;SelectedObject&quot; property:</p>
<pre><controls:EnhancedTreeView
 **SelectedObject="{Binding SelectedObject, Mode=TwoWay}"** 
 ItemsSource="..." /></pre>

<p>It&#39;s important to add &quot;Mode=TwoWay&quot; to the binding, otherwise it won&#39;t work.</p>
</div></div><style type="text/css">@import "/style.css";
@import url('https://fonts.googleapis.com/css?family=Open+Sans|Source+Code+Pro');</style></body></html>